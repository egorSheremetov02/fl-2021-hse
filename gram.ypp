%{
#include <iostream>
#include <string>
#include <map>
#include <stdexcept>
#include <vector>
#include <cstdlib>
#include "./gram_types.h"

using namespace std;

int yylex(); 
int yyerror(const char *p) { cerr << "Error! " << p << endl; return 1; }

vector<Transition *> transitions;
string start_state;
vector<string> terminal_states;
vector<string> states;
unordered_map<string, AutomataState *> automata_map;
unordered_set<string> terminal_states_set;

%}

%union {
  int val; 
  char sym;
  char *word;
  std::vector<char> *sym_vector;
  Transition *transition;
};

%token <sym> RIGHT_PAREN LEFT_PAREN
%token <word> TRANSITIONS_KW
%token <word> STATES_KW
%token <word> ARROW_START
%token <word> ARROW_END
%token <word> START_KW
%token <word> TERMINAL_KW
%token <sym> STAR
%token <sym> COMMA
%token <val> NUM
%token <sym> SYMBOL
%token <word> ID
%nterm <sym_vector> char_list
%nterm <transition> transition_description
%nterm <word> state_description

%%

start: dfa

dfa: 
    ID LEFT_PAREN states_block start_block transitions_block RIGHT_PAREN

states_block: 
    STATES_KW LEFT_PAREN states_list RIGHT_PAREN

states_list: 
    state_description { states.push_back(string($1)); }
  | states_list COMMA state_description { states.push_back(string($3)); }

state_description: 
    ID
  | state_description TERMINAL_KW { $$=$1; terminal_states.push_back(string($$)); }

start_block: 
    START_KW LEFT_PAREN ID RIGHT_PAREN { start_state = string($3);}

transitions_block: 
    TRANSITIONS_KW LEFT_PAREN transitions_list RIGHT_PAREN

transitions_list: 
    transition_description { transitions.push_back($1); }
  | transitions_list COMMA transition_description { transitions.push_back($3); }

transition_description: 
    ID ARROW_START char_list ARROW_END ID { $$ = new Transition{string($1), string($5), *($3)}; }

char_list: 
    STAR  { $$ = new vector<char>(); $$->push_back('*'); }
  | SYMBOL { $$ = new vector<char>(); $$->push_back($1); }
  | char_list COMMA SYMBOL { $$->push_back($3); }
  | char_list COMMA STAR { $$->push_back('*'); }

%%

void test() {
  
}

int build_automata() {
  int ret = 0;
  try {
    
    for (auto & s : states) {
      if (automata_map.find(s) == automata_map.end()) {
        automata_map[s] = new AutomataState{s};
      } else {
        throw logic_error("Given several states with same identifiers");
      }
    }

    if (automata_map.find(start_state) == automata_map.end()) {
      throw logic_error("Can not create start state that does not exist");
    }
    
    for (auto t : transitions) {
      if (automata_map.find(t->from) == automata_map.end() || automata_map.find(t->to) == automata_map.end()) {
        throw logic_error("There are states that do not exist in transitions");
      }
      for (auto c : t->symbols) {
        automata_map[t->from]->add_transition(c, automata_map[t->to]);
      }
    }
    
    for (auto & ts : terminal_states) {
      if (automata_map.find(ts) == automata_map.end()) {
        throw logic_error("Can not make terminal state that does not exist");
      }
      terminal_states_set.insert(ts);
    }
    
  } catch(exception &e) {
    cout << e.what() << endl;
    ret = 1;
  }
  return ret;
}

void test_completeness() {
  for (auto & s : states) {
    if (!automata_map[s]->is_complete_state()) {
      std::cout << "Automata is not complete! Try to fix it by looking at state " << s << std::endl;
      return;
    }
  }
  std::cout << "Automata is complete! Good for you!" << std::endl;
}


int main(int argc, char* argv[]) {
  freopen(argv[1], "r", stdin);
  int code = yyparse();
  if (code) {
    std::cout << "Parsing error occurred" << std::endl;
    return code;
  }
  fclose(stdin);
#ifdef HOME
  std::cout << terminal_states.size() << std::endl;
  std::cout << states.size() << std::endl;
  std::cout << transitions.size() << std::endl;
  std::cout << "start state: " << start_state << std::endl;
  std::cout << "start state length: " << start_state.size() << std::endl;
  for (auto & t : transitions) {
    std::cout << t->from << ' ' << '{';
    for (auto c : t->symbols) {
      std::cout << c << ',';
    }
    std::cout << '}' << ' ' << t->to << std::endl;
  }
  for (auto & t : states) {
    std::cout << t << std::endl;
  }
  for (auto & t : states) {
    std::cout << t << std::endl;
  }
#endif

  code = build_automata();

  if (code) {
    return code;
  }

  test_completeness();

  freopen(argv[2], "r", stdin);
  string word_to_validate;
  std::cin >> word_to_validate;
  fclose(stdin);

  int cur_idx = 0;
  
  AutomataState * current_state = automata_map[start_state];
  try {
    while (cur_idx < word_to_validate.size()) {
      #ifdef HOME
      std::cout << "Current state is " << current_state->name << std::endl;
      #endif
      current_state = current_state->go(word_to_validate[cur_idx++]);
    }
  } catch (...) {
    std::cout << "Word did not pass the check" << std::endl;
  }

  if (terminal_states_set.find(current_state->name) != terminal_states_set.end()) {
    std::cout << "Word successfully passed check" << std::endl;
  } else {
    std::cout << "Word did not pass the check" << std::endl;
  }

  return 0;
}
